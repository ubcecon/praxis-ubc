<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="prAxIs UBC Team   Krishaant Pathmananathan, Yash Mali, Kaiyan Zhang">
<meta name="dcterms.date" content="2025-08-26">

<title>Praxis - ECON 227 - How Do Large Language Models Predict?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../media/praxis-badge.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="keywords" content="economics, econometrics, R, data, machine learning, UBC, COMET, geog 374, econ 325, econ 326, learning, teaching, learn r, r help, help, tutorial, r tutorial for beginners,learning statistics with r, learn r programming, learn statistics, linear regression, r machine learning, learn machine learning, university of british columbia, british columbia, r programming for beginners, r language tutorial, r tutorial for beginners, economic data, econometrics tutoring, economics help for students, economics homework help, oer resources for teachers, open educational resources for teachers, educational resource, oer project, oer materials, oer resources, learn economics online, learn econometrics, teach yourself economics, teach yourself econometrics, econometrics basics for beginners">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../media/praxis-badge-white.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Praxis</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-get-started" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Get Started</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-get-started">    
        <li>
    <a class="dropdown-item" href="../../pages/quickstart.html" rel="" target="">
 <span class="dropdown-text">Quickstart Guide</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-courses" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Courses</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-courses">    
        <li>
    <a class="dropdown-item" href="../../pages/index/index_HIST-414.html" rel="" target="">
 <span class="dropdown-text">HIST-414</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/index/index_AMNE-376.html" rel="" target="">
 <span class="dropdown-text">AMNE-376</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/index/index_SOCI415.html" rel="" target="">
 <span class="dropdown-text">SOCI-415</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/index/index_SOCI280.html" rel="" target="">
 <span class="dropdown-text">SOCI-280</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/index/index_ECON227.html" rel="" target="">
 <span class="dropdown-text">ECON-227</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="../../pages/index/all.html" rel="" target="">
 <span class="dropdown-text">Browse All</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../pages/index/index_topical.html" rel="" target="">
 <span class="menu-text">Topics</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teach-with-praxis" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">Teach With prAxIs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teach-with-praxis">    
        <li>
    <a class="dropdown-item" href="../../pages/teaching_with_comet.html" rel="" target="">
 <span class="dropdown-text">Learn how to teach with prAxIs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/using_comet.html" rel="" target="">
 <span class="dropdown-text">Using prAxIs in the Classroom</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-launch-praxis" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
      <i class="bi bi-play" role="img">
</i> 
 <span class="menu-text">Launch prAxIs</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-launch-praxis">    
        <li>
    <a class="dropdown-item" href="https://open.jupyter.ubc.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-notebooks&amp;urlpath=lab%2Ftree%2Fcomet-notebooks%2F&amp;branch=main" rel="" target=""><i class="bi bi-cloud-check" role="img">
</i> 
 <span class="dropdown-text">Launch on JupyterOpen (with Data)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://open.jupyter.ubc.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-project&amp;urlpath=lab%2Ftree%2Fcomet-project%2F&amp;branch=main" rel="" target=""><i class="bi bi-cloud-check" role="img">
</i> 
 <span class="dropdown-text">Launch on JupyterOpen (lite)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://ubc.syzygy.ca/jupyter/hub/user-redirect/git-pull?repo=https%3A%2F%2Fgithub.com%2Fubcecon%2Fcomet-project&amp;urlpath=lab%2Ftree%2Fcomet-project%2F&amp;branch=main" rel="" target=""><i class="bi bi-gear" role="img">
</i> 
 <span class="dropdown-text">Launch on Syzygy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://colab.research.google.com/github/ubcecon/comet-notebooks/blob/main/" rel="" target=""><i class="bi bi-google" role="img">
</i> 
 <span class="dropdown-text">Launch on Colab</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-notebooks/archive/refs/heads/main.zip" rel="" target=""><i class="bi bi-cloud-download" role="img">
</i> 
 <span class="dropdown-text">Launch Locally</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-open/archive/refs/heads/datasets.zip" rel="" target=""><i class="bi bi-clipboard-data" role="img">
</i> 
 <span class="dropdown-text">Project Datasets</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/ubcecon/comet-open" rel="" target="">
 <span class="dropdown-text">Github Repository</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../#" rel="" target="">
 <span class="menu-text">|</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="button" data-bs-toggle="dropdown" aria-expanded="false" rel="" target="">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../pages/team.html" rel="" target="">
 <span class="dropdown-text">prAxIs Team</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../pages/copyright.html" rel="" target="">
 <span class="dropdown-text">Copyright Information</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#prerequisite" id="toc-prerequisite" class="nav-link active" data-scroll-target="#prerequisite">Prerequisite</a></li>
  <li><a href="#introduction-distribution-of-llm-predictions" id="toc-introduction-distribution-of-llm-predictions" class="nav-link" data-scroll-target="#introduction-distribution-of-llm-predictions">1 Introduction: Distribution of LLM Predictions</a></li>
  <li><a href="#sampling-and-temperature" id="toc-sampling-and-temperature" class="nav-link" data-scroll-target="#sampling-and-temperature">2 Sampling and Temperature</a></li>
  <li><a href="#predicting-stock-prices-from-news-headlines-with-ai" id="toc-predicting-stock-prices-from-news-headlines-with-ai" class="nav-link" data-scroll-target="#predicting-stock-prices-from-news-headlines-with-ai">3 Predicting Stock Prices from News Headlines with AI</a></li>
  <li><a href="#preview-the-news-data" id="toc-preview-the-news-data" class="nav-link" data-scroll-target="#preview-the-news-data">Preview the News Data</a></li>
  <li><a href="#classifying-headline-sentiment-with-llm" id="toc-classifying-headline-sentiment-with-llm" class="nav-link" data-scroll-target="#classifying-headline-sentiment-with-llm">4 Classifying Headline Sentiment with LLM</a></li>
  <li><a href="#getting-stock-price-data" id="toc-getting-stock-price-data" class="nav-link" data-scroll-target="#getting-stock-price-data">5 Getting Stock Price Data</a></li>
  <li><a href="#how-do-ais-feel-about-ai" id="toc-how-do-ais-feel-about-ai" class="nav-link" data-scroll-target="#how-do-ais-feel-about-ai">6 How Do AIs Feel About AI?</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key Takeaways</a></li>
  <li><a href="#glossary" id="toc-glossary" class="nav-link" data-scroll-target="#glossary">Glossary</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/ubcecon/praxis-ubc/issues/new" class="toc-action">Report an issue</a></p></div></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="llm_distributions.ipynb" download="llm_distributions.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ECON 227 - How Do Large Language Models Predict?</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">Language Model Prediction</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>prAxIs UBC Team <br> Krishaant Pathmananathan, Yash Mali, Kaiyan Zhang </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">26 August 2025</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>This notebook explores how large language models (LLMs) work by linking their probability-based predictions to real-world applications. We start with the basics of next-word prediction, then extend the idea to forecasting stock prices using news sentiment.</p>
<section id="prerequisite" class="level3">
<h3 class="anchored" data-anchor-id="prerequisite">Prerequisite</h3>
<p>Before you start, make sure you have the required libraries installed, if not, <strong>uncomment the lines below (i.e.&nbsp;remove the #) and run the cell to install them</strong>:</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># # Core packages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip install \</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#     yfinance \</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#     finvizfinance \</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#     transformers \</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#     pandas \</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#     numpy \</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">#     statsmodels \</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">#     holidays \</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#     plotly \</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#     ipywidgets \</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#     scikit-learn</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># !pip3 install torch torchvision --index-url https://download.pytorch.org/whl/cpu --quiet</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Important:</strong> Run this cell to load the libraries we need for running this notebook.</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load libraries we need to run this notebook</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> glob</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> datetime, timedelta</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> math <span class="im">import</span> sqrt</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> yfinance <span class="im">as</span> yf</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> finvizfinance.quote <span class="im">import</span> finvizfinance</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> transformers <span class="im">import</span> pipeline</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.tsa.statespace.sarimax <span class="im">import</span> SARIMAX</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> holidays</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> plotly.subplots <span class="im">import</span> make_subplots</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ipywidgets <span class="im">as</span> widgets</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, clear_output</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error, mean_absolute_error</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> forecast_plot <span class="im">import</span> create_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="introduction-distribution-of-llm-predictions" class="level3">
<h3 class="anchored" data-anchor-id="introduction-distribution-of-llm-predictions">1 Introduction: Distribution of LLM Predictions</h3>
<p>Large language models like ChatGPT do something that seems very simple: <strong>Next word prediction</strong>.</p>
<p>What does that mean? It means that given a sequence of words, the model predicts the next word in the sequence. For example, if the input is “The cat sat on the”, the model might predict “mat” as the next word.</p>
<p><img src="media/next_word_prediction.png" class="img-fluid"></p>
<p>We saw an example of predicting just one word. These models predict only one word at a time, but they can do this for very long sequences of words.</p>
<p>For example: “bob went to the store” to buy some milk.</p>
<p><img src="media/sequence_words.png" class="img-fluid"></p>
<p>Here, let’s say we will output a total of <span class="math inline">\(T\)</span> words to form a sentence, <span class="math inline">\(w_1, w_2, \ldots, w_{t-1}, w_t\)</span> are the words in the sentence and the subscript <span class="math inline">\(t\)</span> means the word is at the position <span class="math inline">\(t\)</span>.</p>
<p>What the model does is learning the <strong>probability distribution</strong> of the next word given the previous words. It is to create a list of non-negative numbers, one for each possible next word, that add up to 1.</p>
<p>Given the previous words <span class="math inline">\(w_1, w_2, \ldots, w_{t-1}\)</span>, the probability of predicting the next word <span class="math inline">\(w_{t}\)</span> is called <strong>conditional probability</strong>: it essentially measures for all words in the vocabulary, “the probability of the next word being this word, based on what was already said”.</p>
<p>Mathematically, this is defined as below:</p>
<p><span class="math display">\[
P(w_t \mid w_1, w_2, \ldots, w_{t-1}) = \frac{P(w_1, w_2, \ldots, w_{t-1}, w_t)}{P(w_1, w_2, \ldots, w_{t-1})}
\]</span></p>
<p>LLMs can approximate this probability by learning from training datasets. Then, when they make predictions, they will select the word at position <span class="math inline">\(t\)</span> as the word with the maximum <span class="math inline">\(P(w_t \mid w_1, w_2, \ldots, w_{t-1})\)</span>.</p>
<p>With <strong>chain rule</strong>, the model can also use the conditionals for every position to calculate the probability of a whole sentence:</p>
<p><span class="math display">\[
P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t\mid w_1, \ldots w_{t-1})
\]</span></p>
<p>These models give a probability distribution over the entire vocabulary (all the words the model was trained on). We can then pick the word with the highest probability as the next word or we can sample from this distribution to get more varied (creative) outputs.</p>
<p>Let’s look at an example of how this works in practice:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example vocabulary</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>vocab <span class="op">=</span> [<span class="st">'buy'</span>, <span class="st">'some'</span>, <span class="st">'milk'</span>, <span class="st">'along'</span>, <span class="st">'the'</span>, <span class="st">'way'</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Probabilities at each step (toy example)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>probs_step1 <span class="op">=</span> [<span class="fl">0.8</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="fl">0.03</span>, <span class="fl">0.04</span>, <span class="fl">0.03</span>]  <span class="co"># 'buy' high</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>probs_step2 <span class="op">=</span> [<span class="fl">0.05</span>, <span class="fl">0.7</span>, <span class="fl">0.1</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>]   <span class="co"># 'some' high</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>probs_step3 <span class="op">=</span> [<span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="fl">0.75</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>] <span class="co"># 'milk' high</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>prob_distributions <span class="op">=</span> [probs_step1, probs_step2, probs_step3]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>step_labels <span class="op">=</span> [<span class="st">'Step 1: Predict "buy"'</span>, <span class="st">'Step 2: Predict "some"'</span>, <span class="st">'Step 3: Predict "milk"'</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(axes):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    sns.barplot(x<span class="op">=</span>vocab, y<span class="op">=</span>prob_distributions[i], palette<span class="op">=</span><span class="st">'muted'</span>, ax<span class="op">=</span>ax)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    ax.set_title(step_labels[i])</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Probability'</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">''</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Vocabulary'</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight the max prob bar in gold</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    max_idx <span class="op">=</span> prob_distributions[i].index(<span class="bu">max</span>(prob_distributions[i]))</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    ax.bar(max_idx, prob_distributions[i][max_idx], color<span class="op">=</span><span class="st">'gold'</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> patch, token, prob <span class="kw">in</span> <span class="bu">zip</span>(ax.patches, vocab, prob_distributions[i]):</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        height <span class="op">=</span> patch.get_height()</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        ax.annotate(</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>prob<span class="sc">:.2f}</span><span class="ss">"</span>,                            </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>(patch.get_x() <span class="op">+</span> patch.get_width() <span class="op">/</span> <span class="dv">2</span>, height),  </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">3</span>),       </span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>            textcoords<span class="op">=</span><span class="st">"offset points"</span>,</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>,</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">9</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sampling-and-temperature" class="level3">
<h3 class="anchored" data-anchor-id="sampling-and-temperature">2 Sampling and Temperature</h3>
<p>The example above shows us the process of generating <span class="math inline">\(T=3\)</span>: at each step, the model calculates the conditional probability of the next word and then selects the word with the highest probability to insert into the sentence. The final output we obtain is “buy some milk”.</p>
<p>To get more creative responses you change the distribution at the output where you pick the next word. Very simply this involves making the distribution sharper or flatter. If you make the distribution sharper, you are more likely to pick the word with the highest probability. If you make it flatter, you are more likely to pick a word that is not the most probable one.</p>
<p>This is called <strong>temperature</strong>. A higher temperature makes the distribution flatter, while a lower temperature makes it sharper. You would want to use a temperature of more than 1 <span class="math inline">\((1.2-1.5)\)</span> for creative responses, and a temperature of less than 1 <span class="math inline">\((0.1 - 0.5)\)</span> for more focused responses. For a balanced response, you can use a temperature of <span class="math inline">\(0.7-1\)</span>. Another set of parameters are called top-p and top-k sampling.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Example vocabulary</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>vocab <span class="op">=</span> [</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'apple'</span>, <span class="st">'banana'</span>, <span class="st">'cherry'</span>, <span class="st">'date'</span>, <span class="st">'elderberry'</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'fig'</span>, <span class="st">'grape'</span>, <span class="st">'honeydew'</span>, <span class="st">'kiwi'</span>, <span class="st">'lemon'</span>,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'mango'</span>, <span class="st">'nectarine'</span>, <span class="st">'orange'</span>, <span class="st">'papaya'</span>, <span class="st">'quince'</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'raspberry'</span>, <span class="st">'strawberry'</span>, <span class="st">'tangerine'</span>, <span class="st">'ugli'</span>, <span class="st">'watermelon'</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Normalize to sum to 1</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>vocab_size <span class="op">=</span> <span class="bu">len</span>(vocab)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>base_probs <span class="op">=</span> np.random.rand(vocab_size)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>base_probs <span class="op">/=</span> base_probs.<span class="bu">sum</span>()  </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_temperature(probs, temp):</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    logits <span class="op">=</span> np.log(probs <span class="op">+</span> <span class="fl">1e-20</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    scaled_logits <span class="op">=</span> logits <span class="op">/</span> temp</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    exp_logits <span class="op">=</span> np.exp(scaled_logits)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> exp_logits <span class="op">/</span> exp_logits.<span class="bu">sum</span>()</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>temperatures <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">1.5</span>]</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>distributions <span class="op">=</span> [apply_temperature(base_probs, t) <span class="cf">for</span> t <span class="kw">in</span> temperatures]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>), sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (ax, dist, temp) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(axes, distributions, temperatures)):</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    sns.barplot(x<span class="op">=</span>vocab, y<span class="op">=</span>dist, palette<span class="op">=</span><span class="st">'muted'</span>, ax<span class="op">=</span>ax)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f'Temperature = </span><span class="sc">{</span>temp<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="dv">0</span>, <span class="fl">0.25</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Probability'</span> <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">''</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Vocabulary'</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    ax.tick_params(axis<span class="op">=</span><span class="st">'x'</span>, rotation<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight the max-prob bar in gold</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    max_idx <span class="op">=</span> dist.argmax()</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    ax.patches[max_idx].set_color(<span class="st">'gold'</span>)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Annotate each bar with its probability</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> patch, prob <span class="kw">in</span> <span class="bu">zip</span>(ax.patches, dist):</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        height <span class="op">=</span> patch.get_height()</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        ax.annotate(</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>prob<span class="sc">:.2f}</span><span class="ss">"</span>,</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>(patch.get_x() <span class="op">+</span> patch.get_width() <span class="op">/</span> <span class="dv">2</span>, height),</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">3</span>),            <span class="co"># 3 points vertical offset</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>            textcoords<span class="op">=</span><span class="st">"offset points"</span>,</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>            ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>,</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">9</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the example above, we see how the probability distribution changes with different temperatures. A high temperature (1.5) results in a flatter distribution, meaning the model is more likely to sample from less probable tokens, while a low temperature (0.5) results in a sharper distribution, favoring the most probable tokens.</p>
<p>Note that while this is with words and language, the same idea applies to any sequential data, like stock prices, weather data, etc. The model looks at what happened before and tries to guess what comes next.</p>
<p>If you are interested in understanding the inner workings of these models, take a look at the interactive visualization at <a href="https://poloclub.github.io/transformer-explainer/">The Illustrated Transformer</a> . It provides an excellent, hands-on way to explore the core ideas behind modern language models.</p>
<p>So, just like it guesses the next word in a sentence, it can guess the next day’s temperature or the next movement in a stock price, based on the pattern it sees in the earlier numbers.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">9</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate actual data: random walk + small trend</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>actual_data <span class="op">=</span> np.cumsum(np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, n)) <span class="op">+</span> <span class="dv">50</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Predictor approximates entire data closely with small noise everywhere</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>predicted <span class="op">=</span> actual_data <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.2</span>, n)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Posterior uncertainty: low and roughly constant over entire period</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>posterior_std <span class="op">=</span> np.full(n, <span class="fl">0.3</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>upper <span class="op">=</span> predicted <span class="op">+</span> posterior_std</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>lower <span class="op">=</span> predicted <span class="op">-</span> posterior_std</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>,<span class="dv">6</span>))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(n), actual_data, label<span class="op">=</span><span class="st">"Actual Data"</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(n), predicted, label<span class="op">=</span><span class="st">"Predicted"</span>, color<span class="op">=</span><span class="st">'orange'</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>plt.axvline(x<span class="op">=</span>m<span class="op">-</span><span class="dv">1</span>, color<span class="op">=</span><span class="st">'black'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="st">"Observed / Future Split"</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Time"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Stock price over time."</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Typically, when building a model to predict stock prices, you would use more information than just the past prices. For example, you might include things like public sentiment (how people feel about the stock), news headlines, or other features that could influence the price.</p>
<p>In the examples below, that’s exactly what we’re going to try! We’ll see how adding these extra features can help the model make better predictions about what happens next.</p>
</section>
<section id="predicting-stock-prices-from-news-headlines-with-ai" class="level3">
<h3 class="anchored" data-anchor-id="predicting-stock-prices-from-news-headlines-with-ai">3 Predicting Stock Prices from News Headlines with AI</h3>
<p>Just like LLMs predict the next word based on the context of prior words:</p>
<p><span class="math display">\[
P(w_t \mid w_1, w_2, \ldots, w_{t-1})
\]</span></p>
<p>We can use similar models to predict the next value in a time series, like <strong>stock prices</strong> or <strong>percentage changes</strong> in returns.</p>
<p>While prediction of next word in language models is inherently <strong>univariate</strong> that the model predicts the next word based solely on the sequence of previous words, predicting daily stock returns is often a <strong>multivariate</strong> problem as more exogenous factors must be taken into account. Here, we don’t just use past stock prices (returns) as context, but also incorporate <strong>additional features</strong> such as public sentiment from news headlines.</p>
<p>In other words, instead of predicting the next token from a single stream (words), we predict the next value in a time series using <strong>multiple sources of information</strong>: historical price data and external signals like news sentiment. This richer, multivariate context allows the model to capture more complex relationships and potentially make more accurate forecasts.</p>
<p>The comparison of word prediction and stock price prediction is given as follows:</p>
<table class="table">
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>Word Prediction</th>
<th>Stock Price Prediction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Previous words</td>
<td>Past daily returns + aggregated news sentiment</td>
</tr>
<tr class="even">
<td>Next word prediction</td>
<td>Future return prediction</td>
</tr>
<tr class="odd">
<td>Attention to important words</td>
<td>Feature weights on returns <strong>and</strong> sentiment</td>
</tr>
<tr class="even">
<td>Temperature to control randomness</td>
<td>Confidence or prediction intervals in forecasts</td>
</tr>
<tr class="odd">
<td>Word probability distribution</td>
<td>Forecasted return distribution</td>
</tr>
</tbody>
</table>
<p>In this case study, we use a language model to analyze real-time news headlines alongside historical stock prices in order to forecast short-term changes in stock value.</p>
<p>You will:</p>
<ul>
<li>Collect news headlines about real companies (like Amazon or Starbucks)</li>
<li>Use a pre-trained AI model to classify the <strong>sentiment</strong> (positive or negative) of these news headlines</li>
<li>Combine that with stock prices</li>
<li>Use a forecasting model to predict future price changes</li>
<li>Visualize your results interactively</li>
</ul>
</section>
<section id="preview-the-news-data" class="level3">
<h3 class="anchored" data-anchor-id="preview-the-news-data">Preview the News Data</h3>
<p>Here we use the <code>finvizfinance</code> packages to retrieve real-time news headlines for companies like Starbucks (SBUX).</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The code below will give us a snapshot of the 100 most recent news headlines for a particular stock in the last 30 days.  </span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_news_data(ticker):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    stock <span class="op">=</span> finvizfinance(ticker)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    news_df <span class="op">=</span> stock.ticker_news()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    news_df <span class="op">=</span> pd.DataFrame(news_df)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Drop NaN and clean whitespace</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    news_df <span class="op">=</span> news_df.dropna(subset<span class="op">=</span>[<span class="st">"Title"</span>])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    news_df <span class="op">=</span> news_df[news_df[<span class="st">"Title"</span>].<span class="bu">str</span>.strip() <span class="op">!=</span> <span class="st">""</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    news_df[<span class="st">'Title'</span>] <span class="op">=</span> news_df[<span class="st">'Title'</span>].<span class="bu">str</span>.lower()</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    news_df[<span class="st">'Date'</span>] <span class="op">=</span> pd.to_datetime(news_df[<span class="st">'Date'</span>])</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    news_df[<span class="st">'DateOnly'</span>] <span class="op">=</span> news_df[<span class="st">'Date'</span>].dt.date</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    news_df[<span class="st">"Ticker"</span>] <span class="op">=</span> ticker.upper()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove the 'Date' column</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    news_df <span class="op">=</span> news_df.drop(columns<span class="op">=</span>[<span class="st">'Date'</span>])</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> news_df.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># For the sake of reproducibility (so we always get the same results), we will use a a dataset that was scrapped using the same method at an earlier time (July - 2025)</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the line below get a more recent snapshot of the data! </span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co"># SBUX_news_df = get_news_data("SBUX")</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co"># SBUX_news_df.to_csv("datasets/SBUX_news.csv", index=False)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s look at what the cleaned news data looks like. We’ll start with Starbucks (<code>SBUX</code>).</p>
<p>Each row is a headline, what website it was from, the date it was published and a ticker indicating what stock it is for.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>SBUX_news_df <span class="op">=</span> pd.read_csv(<span class="st">"datasets/SBUX_news.csv"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>SBUX_news_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s take a closer look at the news titles. What would you say about their sentiment?</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> SBUX_news_df[<span class="st">'Title'</span>].tolist()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"News on Starbucks:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, title <span class="kw">in</span> <span class="bu">enumerate</span>(titles[:<span class="dv">5</span>], start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">. </span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="classifying-headline-sentiment-with-llm" class="level3">
<h3 class="anchored" data-anchor-id="classifying-headline-sentiment-with-llm">4 Classifying Headline Sentiment with LLM</h3>
<p>Earlier, we explored how <strong>large language models (LLMs)</strong> predict the <em>next word</em> by learning the probability distribution of possible outcomes based on context.</p>
<p>Now, we apply a similar idea to <strong>entire sentences</strong>: in this case, financial news headlines. Instead of predicting the next word, the model assigns a probability to each <strong>sentiment category</strong> (e.g.&nbsp;POSITIVE, NEGATIVE, or NEUTRAL).</p>
<section id="how-it-works" class="level4">
<h4 class="anchored" data-anchor-id="how-it-works">How it works:</h4>
<ul>
<li>A pre-trained model reads the headline.</li>
<li>It assigns probabilities to the sentiment labels.</li>
<li>We keep only <strong>positive</strong> or <strong>negative</strong> headlines, since those are more likely to affect stock prices.</li>
</ul>
<p>This is like asking:</p>
<blockquote class="blockquote">
<p><em>Given the words in this sentence, what is the most likely emotion behind it?</em></p>
</blockquote>
<p>We will rely on some AI tools to figure out.</p>
<p>BERT (short for <em>Bidirectional Encoder Representations from Transformers</em>) is a pretrained language model that learns a word’s meaning by looking at the words <em>before and after</em> it, so it understands context and tone well. And Hugging Face is an open-source platform and Python library that hosts many pretrained models (like BERT) and provides easy tools.</p>
<p>In this notebook, we are going to use Hugging Face’s <code>pipeline()</code> function to load a <strong>RoBERTa</strong> model: an optimized version of the BERT model trained to understand the tone of text. Although it is specifically trained on tweets and social media text. It’s well-suited to handling short, informal writing like news headlines.</p>
<p>This builds directly on our earlier discussion of LLMs predicting <strong>probability distributions</strong>, but here, the prediction is over <strong>sentiment classes</strong> rather than words.</p>
<p>We now apply a pre-trained <strong>large language model</strong> to each headline.</p>
<p>It returns:</p>
<ul>
<li><code>POSITIVE</code>: news that sounds good (e.g., “profits surge”)</li>
<li><code>NEGATIVE</code>: news that sounds bad (e.g., “lawsuit filed”)</li>
</ul>
<blockquote class="blockquote">
<p><em>Can you think of a positive and negative news headline?</em></p>
</blockquote>
<p>Note that we will skip <code>NEUTRAL</code> news to focus on strong market signals.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Here we are just specifying the classifier (AI model) that decides on a sentiment </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>classifier <span class="op">=</span> pipeline(<span class="st">"sentiment-analysis"</span>, model<span class="op">=</span><span class="st">"cardiffnlp/twitter-roberta-base-sentiment-latest"</span>, device<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># define a function to classify sentiment of each text </span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> classify_sentiment(text):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> classifier(text)[<span class="dv">0</span>][<span class="st">"label"</span>].upper()</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># define classify_sentiment to entire dataframe</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_sentiment(news_df):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    news_df[<span class="st">"Sentiment"</span>] <span class="op">=</span> news_df[<span class="st">"Title"</span>].<span class="bu">apply</span>(classify_sentiment)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> news_df <span class="co"># [news_df["Sentiment"] != "NEUTRAL"] # remove neutral headlines</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> process_sentiment(news_df):</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> news_df.groupby([<span class="st">"DateOnly"</span>, <span class="st">"Sentiment"</span>]).size().unstack(fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> grouped.reindex(columns<span class="op">=</span>[<span class="st">"POSITIVE"</span>, <span class="st">"NEGATIVE"</span>], fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate a rolling 7-day total of positive headlines</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_avg_positive"</span>] <span class="op">=</span> grouped[<span class="st">"POSITIVE"</span>].rolling(window<span class="op">=</span><span class="dv">7</span>, min_periods<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate a rolling 7-day total of negative headlines</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_avg_negative"</span>] <span class="op">=</span> grouped[<span class="st">"NEGATIVE"</span>].rolling(window<span class="op">=</span><span class="dv">7</span>, min_periods<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>()</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the percentage of positive headlines each day (out of total positive + negative)</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_pct_positive"</span>] <span class="op">=</span> grouped[<span class="st">"POSITIVE"</span>] <span class="op">/</span> (grouped[<span class="st">"POSITIVE"</span>] <span class="op">+</span> grouped[<span class="st">"NEGATIVE"</span>])</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grouped.reset_index()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s use our model to see wether the sentence “I hate bananas” is negative or positive</p>
<blockquote class="blockquote">
<p><em>Try changing the words inside classify sentiment to see wether its is classified positive or negative</em></p>
</blockquote>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>classify_sentiment(<span class="st">"I hate bananas"</span>)        <span class="co"># You can change the words inside the function to test anything you want! </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s apply this to our entire <code>SBUX_news_df</code> and see how each news headline is classified.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>news_df <span class="op">=</span> apply_sentiment(SBUX_news_df)       <span class="co"># Classify sentiment of each Starbucks news headline</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>news_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"News Titles and Sentiments</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> news_df.iterrows():</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Title: </span><span class="sc">{</span>row[<span class="st">'Title'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">Sentiment: </span><span class="sc">{</span>row[<span class="st">'Sentiment'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s summarize the sentiment results by date. For each day we count the number of positive and negative headlines, then calculate 7-day moving averages and the daily percentage of positive news. This gives us a quick overview of news sentiment trends over time.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sentiment_df <span class="op">=</span> process_sentiment(news_df)       <span class="co"># Summarize daily sentiment statistics</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>sentiment_df.head()                             <span class="co"># Display the first 5 rows of the dataframe</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="what-this-table-shows" class="level4">
<h4 class="anchored" data-anchor-id="what-this-table-shows">What this table shows?</h4>
<p>This table is the output of a function that summarizes news sentiment over time.</p>
<p>Each row corresponds to a specific date and gives us a snapshot of how positive or negative the news headlines were for that day and the surrounding week.</p>
<p>Markets move not just based on today’s headlines, but on <strong>short-term trends</strong> in public sentiment.<br>
This table lets us track how optimism or pessimism is <strong>building up over time</strong>, which we can later use to help predict stock price movements.</p>
</section>
<section id="why-is-this-useful" class="level4">
<h4 class="anchored" data-anchor-id="why-is-this-useful">Why is this useful?</h4>
<ul>
<li>We know that in the last 100 news stories about NVIDIA 24 have been positive and 5 have been negative.</li>
<li>If the <code>7day_pct_positive</code> is rising, the overall tone of news is getting more optimistic.</li>
<li>If it’s dropping, it could mean public or investor concern is growing.</li>
<li>We can later plot this and compare it against stock price to see if sentiment influences market behavior.</li>
</ul>
</section>
</section>
<section id="getting-stock-price-data" class="level3">
<h3 class="anchored" data-anchor-id="getting-stock-price-data">5 Getting Stock Price Data</h3>
<p>We are using the <code>yfinance</code> package to get real stock price data directly from Yahoo Finance. The function below helps us download historical stock prices and compute the daily percentage change in the stock’s closing price. To make sure our results are replicable, this data has been saved as a <code>.csv</code> file “datasets/SBUX_price.csv”</p>
<p>This allows us to analyze how stock prices change over time.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The code below will give us a snapshot of stock prices for the duration in we have news headlines for.  </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_stock_data(ticker, start, end):</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    stock <span class="op">=</span> yf.download(ticker, start<span class="op">=</span>start, end<span class="op">=</span>end)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Flatten columns if multi-indexed (e.g., multiple tickers)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(stock.columns, pd.MultiIndex):</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        stock.columns <span class="op">=</span> [<span class="st">'_'</span>.join(col).strip() <span class="cf">for</span> col <span class="kw">in</span> stock.columns]  <span class="co"># "Close_SBUX", etc.</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        close_col <span class="op">=</span> <span class="ss">f"Close_</span><span class="sc">{</span>ticker<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        close_col <span class="op">=</span> <span class="st">"Close"</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    stock[<span class="st">"Pct_Change"</span>] <span class="op">=</span> stock[close_col].pct_change() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    stock.reset_index(inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    stock[<span class="st">"DateOnly"</span>] <span class="op">=</span> pd.to_datetime(stock[<span class="st">"Date"</span>])</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> stock[[<span class="st">"DateOnly"</span>, <span class="st">"Pct_Change"</span>]]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># merges sentiment and stock data by date, and lags sentiment by one day to align with price changes.</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine_data(sent_df, stock_df):</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    sent_df <span class="op">=</span> sent_df.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    stock_df <span class="op">=</span> stock_df.reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    sent_df[<span class="st">"DateOnly"</span>] <span class="op">=</span> pd.to_datetime(sent_df[<span class="st">"DateOnly"</span>])</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    stock_df[<span class="st">"DateOnly"</span>] <span class="op">=</span> pd.to_datetime(stock_df[<span class="st">"DateOnly"</span>])</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        pd.merge(sent_df, stock_df, on<span class="op">=</span><span class="st">"DateOnly"</span>, how<span class="op">=</span><span class="st">"inner"</span>)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>          .assign(lagged_sentiment<span class="op">=</span><span class="kw">lambda</span> df: df[<span class="st">"7day_pct_positive"</span>].shift(<span class="dv">1</span>))</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="co"># For the sake of reproducibility (so we always get the same results), we will use a a dataset that was scrapped using the same method at an earlier time (July - 2025)</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the line below get a more recent snapshot of the data ! </span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span class="co"># SBUX_news_df["DateOnly"] = pd.to_datetime(SBUX_news_df["DateOnly"])</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="co"># start_date = SBUX_news_df["DateOnly"].min() - pd.Timedelta(days=1) </span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span class="co"># end_date = SBUX_news_df["DateOnly"].max() + pd.Timedelta(days=1) </span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="co"># stock_df = get_stock_data("SBUX", start_date, end_date)</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="co"># stock_df.to_csv("datasets/SBUX_price.csv", index=False)</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>SBUX_price_df <span class="op">=</span> pd.read_csv(<span class="st">"datasets/SBUX_price.csv"</span>)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>SBUX_price_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we bring together the sentiment summary data and the stock price changes. By merging these two datasets, we can analyze how changes in news sentiment might be related to changes in Starbucks’ stock price. This combined dataset will help us answer the question: “Does positive news sentiment lead to an increase in stock price?”</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>combined_df <span class="op">=</span> combine_data(sentiment_df, SBUX_price_df)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>combined_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="forecasting-future-stock-changes-with-sentiment" class="level4">
<h4 class="anchored" data-anchor-id="forecasting-future-stock-changes-with-sentiment">Forecasting Future Stock Changes with Sentiment</h4>
<p>In this notebook, we will try to predict future stock price changes using the <strong>SARIMAX model</strong>, a powerful forecasting model that allows us to include external information, in our case, <strong>public sentiment</strong>. For those who are interested in learning more about the SARIMAX model and its implementation in Python, see this <a href="https://www.geeksforgeeks.org/python/complete-guide-to-sarimax-in-python/">comprehensive guide</a> on GeeksforGeeks.</p>
<p>Below, we define two key functions for our forecasting workflow:</p>
<ul>
<li><code>get_future_dates()</code>: Returns the next business days for which we want to make predictions.</li>
<li><code>fit_and_forecast()</code>: Uses both historical stock prices and recent news sentiment to predict how Starbucks’ (SBUX) stock price might change over the next few days. This function fits a SARIMAX model, which incorporates both past price data and the influence of news sentiment, and then generates forecasts along with confidence intervals.</li>
</ul>
<p>Next, we will use a pre-defined <code>create_plot()</code> function to generate an interactive line chart that visualizes both stock price percentage changes and sentiment trends over time. This allows us to explore the relationship between market sentiment and stock performance in a clear, interactive way.</p>
<p>By combining these functions, we can see how shifts in news sentiment may impact SBUX’s future stock movements. The forecasting approach essentially answers the question: “Given recent sentiment, what does the model predict for this stock’s price in the coming days?”</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># business days we should forecast for </span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_future_dates(start_date, num_days):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(start_date, pd.Timestamp):</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        start_date <span class="op">=</span> pd.to_datetime(start_date)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    us_holidays <span class="op">=</span> holidays.US()</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    future_dates <span class="op">=</span> []</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    current_date <span class="op">=</span> start_date <span class="op">+</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(future_dates) <span class="op">&lt;</span> num_days:</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_date.weekday() <span class="op">&lt;</span> <span class="dv">5</span> <span class="kw">and</span> current_date.date() <span class="kw">not</span> <span class="kw">in</span> us_holidays:</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            future_dates.append(current_date)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        current_date <span class="op">+=</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> future_dates</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co"># prediction model</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit_and_forecast(combined_df, forecast_steps<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    combined_df <span class="op">=</span> combined_df.dropna(subset<span class="op">=</span>[<span class="st">'Pct_Change'</span>, <span class="st">'lagged_sentiment'</span>])</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    endog <span class="op">=</span> combined_df[<span class="st">'Pct_Change'</span>]</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    exog <span class="op">=</span> combined_df[<span class="st">'lagged_sentiment'</span>]</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> SARIMAX(endog, exog<span class="op">=</span>exog, order<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> model.fit(disp<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    future_dates <span class="op">=</span> get_future_dates(combined_df.index[<span class="op">-</span><span class="dv">1</span>], forecast_steps)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    future_exog <span class="op">=</span> np.tile(combined_df[<span class="st">'lagged_sentiment'</span>].iloc[<span class="op">-</span><span class="dv">1</span>], forecast_steps).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    forecast <span class="op">=</span> fit.get_forecast(steps<span class="op">=</span>forecast_steps, exog<span class="op">=</span>future_exog)</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> forecast.predicted_mean, forecast.conf_int(), future_dates</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="plot-sentiment-vs-stock-change-forecast" class="level4">
<h4 class="anchored" data-anchor-id="plot-sentiment-vs-stock-change-forecast">Plot: Sentiment vs Stock % Change Forecast</h4>
<p>This chart shows how news sentiment about a company relates to its stock price changes over time, and how we can use this relationship to make simple predictions.</p>
<ul>
<li>The blue line shows the standardized 7-day average of positive sentiment extracted from financial news headlines. A higher value means news sentiment was more positive.</li>
<li>The green line shows the actual daily percentage change in the company’s stock price.</li>
<li>The red line shows our simple <strong>forecast</strong> of future stock movement based on past sentiment trends. The shaded red area represents uncertainty around the forecast (a 95% confidence interval).</li>
</ul>
<p>We want to see whether the emotions in the news (blue) can help us predict price changes (green and red). If they move together, it suggests that public mood might influence investor behavior.</p>
<blockquote class="blockquote">
<p>This plot helps us visualize correlations and test basic forecasting using real-world data like stock prices and media sentiment.</p>
</blockquote>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>combined_df[<span class="st">'DateOnly'</span>] <span class="op">=</span> pd.to_datetime(combined_df[<span class="st">'DateOnly'</span>])  <span class="co"># convert to datetime</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>combined_df.set_index(<span class="st">'DateOnly'</span>, inplace<span class="op">=</span><span class="va">True</span>)  <span class="co"># use as index</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>combined_df.sort_index(inplace<span class="op">=</span><span class="va">True</span>)  <span class="co"># ensure time order</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>forecast_mean, forecast_ci, forecast_index <span class="op">=</span> fit_and_forecast(combined_df)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>create_plot(combined_df, forecast_mean, forecast_ci, forecast_index)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Disclaimer</strong>: This is a simplified model. In reality, stock prices are influenced by many factors, such as interest rates, earnings reports, geopolitical events, and investor speculation. This chart only considers one variable: news sentiment. It should not be used for actual trading decisions.</p>
</blockquote>
<blockquote class="blockquote">
<p><em>Think about what you would include in a model other than news to help us predict how a stock price might change ?</em></p>
</blockquote>
</section>
</section>
<section id="how-do-ais-feel-about-ai" class="level3">
<h3 class="anchored" data-anchor-id="how-do-ais-feel-about-ai">6 How Do AIs Feel About AI?</h3>
<p>In this section of the notebook, we explore how our <strong>AI Sentiment Analysis model</strong> feels about AI-related stocks. That’s a mouthful!</p>
<p>The goal is to see if public sentiment (as captured by the headlines) is generally optimistic or pessimistic toward leading AI companies — as interpreted by another AI (we are using BERT here!).</p>
<p>We’ll start by selecting the <a href="https://www.forbes.com/advisor/investing/best-ai-stocks/">top 10 AI stocks in 2025</a> as suggested by financial news magazine, Forbes - <code>ACN</code> (Accenture) - <code>ADBE</code> (Adobe) - <code>AMD</code> (Advanced Micro Devices) - <code>APP</code> (Applovin) - <code>AVGO</code> (Broadcom) - <code>CRM</code> (Salesforce) - <code>MRVL</code> (Marvell Technology) - <code>MU</code> (Micron Technology) - <code>NVDA</code> (NVIDIA) - <code>QCOM</code> (Qualcomm)</p>
<p>For each company, we will: 2. Classify the sentiment using our <code>RoBERTa</code>-based model 1. Pull recent news headlines 3. Analyze the <strong>7-day rolling trends</strong> in public sentiment 4. Compare results across companies</p>
<p>Let’s find out if the machines love themselves ?</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This code collects recent news headlines for each company in our AI stock list. It uses our  `get_news_data()` which we defined above. </span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>ai_tickers <span class="op">=</span> [<span class="st">"ACN"</span>, <span class="st">"ADBE"</span>, <span class="st">"AMD"</span>, <span class="st">"APP"</span>, <span class="st">"AVGO"</span>, <span class="st">"CRM"</span>, <span class="st">"MRVL"</span>, <span class="st">"MU"</span>, <span class="st">"NVDA"</span>, <span class="st">"QCOM"</span>] <span class="co"># Top 10 AI stocks </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>all_news <span class="op">=</span> []</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_all_news(ticker_list):</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    all_news <span class="op">=</span> []</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ticker <span class="kw">in</span> ticker_list:</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            news <span class="op">=</span> get_news_data(ticker)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>            all_news.append(news)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Failed to get news for </span><span class="sc">{</span>ticker<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> all_news:</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.concat(all_news, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.DataFrame()</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co"># For the sake of reproducability (so we always get the same results), we will use a a dataset that was scrapped using the same method at an earlier time (July - 2025)</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the line below get a more recent snapshot of the data !</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage :</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_combined_news_df = fetch_all_news(ai_tickers)</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co"># #AI_combined_news_df = pd.concat(all_news, ignore_index=True)</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_combined_news_df.to_csv("datasets/AI_news_snapshot.csv", index=False)</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_sentiment_news_df = apply_sentiment(AI_combined_news_df)         </span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_sentiment_news_df.to_csv("datasets/AI_news_sentiment.csv", index=False)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>AI_sentiment_news_df <span class="op">=</span> pd.read_csv(<span class="st">"datasets/AI_news_sentiment.csv"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>AI_sentiment_news_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This<code>AI_process_sentiment</code> does for a bunch of companies what we did for SBUX. It automatically collect all their news headlines and put them in one place for analysis.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> AI_process_sentiment(news_df):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    filtered <span class="op">=</span> news_df[news_df[<span class="st">"Sentiment"</span>].isin([<span class="st">"POSITIVE"</span>, <span class="st">"NEGATIVE"</span>])].copy()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Group by DateOnly, Ticker, Sentiment → count headlines</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> (</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        filtered</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        .groupby([<span class="st">"DateOnly"</span>, <span class="st">"Ticker"</span>, <span class="st">"Sentiment"</span>])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        .size()</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        .unstack(fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        .reset_index()</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure both sentiment columns exist</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"POSITIVE"</span> <span class="kw">not</span> <span class="kw">in</span> grouped.columns:</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        grouped[<span class="st">"POSITIVE"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"NEGATIVE"</span> <span class="kw">not</span> <span class="kw">in</span> grouped.columns:</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        grouped[<span class="st">"NEGATIVE"</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort for rolling computation</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    grouped <span class="op">=</span> grouped.sort_values([<span class="st">"Ticker"</span>, <span class="st">"DateOnly"</span>])</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 7-day rolling sums by ticker</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_avg_positive"</span>] <span class="op">=</span> (</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        grouped.groupby(<span class="st">"Ticker"</span>)[<span class="st">"POSITIVE"</span>]</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        .transform(<span class="kw">lambda</span> x: x.rolling(window<span class="op">=</span><span class="dv">7</span>, min_periods<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>())</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_avg_negative"</span>] <span class="op">=</span> (</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        grouped.groupby(<span class="st">"Ticker"</span>)[<span class="st">"NEGATIVE"</span>]</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        .transform(<span class="kw">lambda</span> x: x.rolling(window<span class="op">=</span><span class="dv">7</span>, min_periods<span class="op">=</span><span class="dv">1</span>).<span class="bu">sum</span>())</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute % positive</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>    grouped[<span class="st">"7day_pct_positive"</span>] <span class="op">=</span> grouped[<span class="st">"7day_avg_positive"</span>] <span class="op">/</span> (</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>        grouped[<span class="st">"7day_avg_positive"</span>] <span class="op">+</span> grouped[<span class="st">"7day_avg_negative"</span>]</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grouped[[<span class="st">"DateOnly"</span>, <span class="st">"Ticker"</span>, <span class="st">"7day_pct_positive"</span>]]</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>AI_sentiment_df <span class="op">=</span> AI_process_sentiment(AI_sentiment_news_df)</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>AI_sentiment_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="like-we-did-with-the-sbux-stock-above-lets-get-stock-prices-for-all-of-our-ai-stocks-now." class="level4">
<h4 class="anchored" data-anchor-id="like-we-did-with-the-sbux-stock-above-lets-get-stock-prices-for-all-of-our-ai-stocks-now.">Like we did with the <code>SBUX</code> stock above let’s get stock prices for all of our AI stocks now.</h4>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Match date range to your sentiment dataset</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>start_date <span class="op">=</span> pd.to_datetime(AI_sentiment_df[<span class="st">"DateOnly"</span>]).<span class="bu">min</span>() <span class="op">-</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>end_date <span class="op">=</span> pd.to_datetime(AI_sentiment_df[<span class="st">"DateOnly"</span>]).<span class="bu">max</span>()</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_and_save_stock_data(ticker_list, start_date, end_date, save_dir<span class="op">=</span><span class="st">"data/ai_prices"</span>):</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Fetches stock price data for each ticker in the list and saves it as a CSV file.</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Prints a success or error message for each ticker.</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    os.makedirs(save_dir, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ticker <span class="kw">in</span> ticker_list:</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>            stock_df <span class="op">=</span> get_stock_data(ticker, start_date, end_date)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>            stock_df[<span class="st">"Ticker"</span>] <span class="op">=</span> ticker</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            file_path <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>save_dir<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>ticker<span class="sc">}</span><span class="ss">_price.csv"</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            stock_df.to_csv(file_path, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Failed to get stock data for </span><span class="sc">{</span>ticker<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="co"># For the sake of reproducability (so we always get the same results), we will use a a dataset that was scrapped using the same method at an earlier time (July - 2025)</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment the line below get a more recent snapshot of the data !</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage :</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="co"># fetch_and_save_stock_data(ai_tickers, "start_date", "end_date")</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co"># price_files = glob.glob("data/ai_prices/*.csv")</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co"># price_dfs = [pd.read_csv(f) for f in price_files]</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_combined_price_df = pd.concat(price_dfs, ignore_index=True)</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="co"># AI_combined_price_df.to_csv("datasets/AI_top10_price_snapshot.csv", index=False)</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>AI_stock_prices <span class="op">=</span> pd.read_csv(<span class="st">"datasets/AI_top10_price_snapshot.csv"</span>)</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>AI_stock_prices.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we did before let’s merge everything into one dataframe to analyse it!</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure both DateOnly columns are datetime</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>AI_sentiment_df[<span class="st">'DateOnly'</span>] <span class="op">=</span> pd.to_datetime(AI_sentiment_df[<span class="st">'DateOnly'</span>])</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>AI_stock_prices[<span class="st">'DateOnly'</span>] <span class="op">=</span> pd.to_datetime(AI_stock_prices[<span class="st">'DateOnly'</span>])</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge on DateOnly and Ticker</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> pd.merge(</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    AI_stock_prices,</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    AI_sentiment_df,</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    on<span class="op">=</span>[<span class="st">'DateOnly'</span>, <span class="st">'Ticker'</span>],</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    how<span class="op">=</span><span class="st">'inner'</span>                  </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>final_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Similar to our approach with the <code>SBUX</code> stock price, we can fit a SARIMAX model to this combined dataset and forecast the percentage change in AI stock prices for the next 7 business days, using both historical price trends and recent news sentiment as inputs.</p>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit_and_forecast(final_df, forecast_steps<span class="op">=</span><span class="dv">7</span>):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> statsmodels.tsa.statespace.sarimax <span class="im">import</span> SARIMAX</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Drop missing values</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    final_df <span class="op">=</span> final_df.dropna(subset<span class="op">=</span>[<span class="st">'Pct_Change'</span>, <span class="st">'lagged_sentiment'</span>])</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define endogenous and exogenous variables</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    endog <span class="op">=</span> final_df[<span class="st">'Pct_Change'</span>]</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    exog <span class="op">=</span> final_df[<span class="st">'lagged_sentiment'</span>]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit SARIMAX</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> SARIMAX(endog, exog<span class="op">=</span>exog, order<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), enforce_stationarity<span class="op">=</span><span class="va">False</span>, enforce_invertibility<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    fit <span class="op">=</span> model.fit(disp<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Future exog (use last known lagged sentiment)</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    last_sentiment <span class="op">=</span> exog.iloc[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    future_exog <span class="op">=</span> np.full(shape<span class="op">=</span>(forecast_steps,), fill_value<span class="op">=</span>last_sentiment)</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Forecast</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    forecast <span class="op">=</span> fit.get_forecast(steps<span class="op">=</span>forecast_steps, exog<span class="op">=</span>future_exog)</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    forecast_mean <span class="op">=</span> forecast.predicted_mean</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    forecast_ci <span class="op">=</span> forecast.conf_int()</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create future dates</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    last_date <span class="op">=</span> final_df.index[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    forecast_index <span class="op">=</span> pd.date_range(start<span class="op">=</span>last_date <span class="op">+</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>), periods<span class="op">=</span>forecast_steps, freq<span class="op">=</span><span class="st">'B'</span>)</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> forecast_mean, forecast_ci, forecast_index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>final_df <span class="op">=</span> final_df.copy()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort and index</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'DateOnly'</span>] <span class="op">=</span> pd.to_datetime(final_df[<span class="st">'DateOnly'</span>])</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>final_df.set_index(<span class="st">'DateOnly'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>final_df.sort_index(inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create lagged and standardized sentiment</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'sentiment_std'</span>] <span class="op">=</span> (</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    final_df[<span class="st">'7day_pct_positive'</span>] <span class="op">-</span> final_df[<span class="st">'7day_pct_positive'</span>].mean()</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>) <span class="op">/</span> final_df[<span class="st">'7day_pct_positive'</span>].std()</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>final_df[<span class="st">'lagged_sentiment'</span>] <span class="op">=</span> final_df[<span class="st">'sentiment_std'</span>].shift(<span class="dv">1</span>)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>final_df.dropna(subset<span class="op">=</span>[<span class="st">'lagged_sentiment'</span>, <span class="st">'Pct_Change'</span>], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Now call</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>forecast_mean, forecast_ci, forecast_index <span class="op">=</span> fit_and_forecast(final_df)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>create_plot(final_df, forecast_mean, forecast_ci, forecast_index)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="how-well-does-the-model-predict" class="level4">
<h4 class="anchored" data-anchor-id="how-well-does-the-model-predict">How well does the model predict?</h4>
<p>We can fetch the actual data to see how well our model predicts the AI stocks.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create function to generate the compare window</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_compare_window(compare_start, compare_target_end):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define today to avoid fetching beyond range</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    today <span class="op">=</span> pd.Timestamp(datetime.utcnow().date())  <span class="co"># use UTC date</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    compare_end <span class="op">=</span> <span class="bu">min</span>(today, compare_target_end)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> compare_start, compare_end</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create function to fetch the actual percentage change</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fetch_actual_pct_changes(ticker_list, start_date, end_date, buffer_days<span class="op">=</span><span class="dv">7</span>):</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This function fetches the pct change of the given list of tickers and return as a DataFrame</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    rows <span class="op">=</span> []</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fetch one ticker at a time to avoid group_by complexity</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    start_fetch <span class="op">=</span> (start_date <span class="op">-</span> pd.Timedelta(days<span class="op">=</span>buffer_days)).strftime(<span class="st">'%Y-%m-</span><span class="sc">%d</span><span class="st">'</span>)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    end_fetch <span class="op">=</span> (end_date <span class="op">+</span> pd.Timedelta(days<span class="op">=</span><span class="dv">1</span>)).strftime(<span class="st">'%Y-%m-</span><span class="sc">%d</span><span class="st">'</span>)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> ticker_list:</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>            df <span class="op">=</span> yf.download(t, start<span class="op">=</span>start_fetch, end<span class="op">=</span>end_fetch, progress<span class="op">=</span><span class="va">False</span>, interval<span class="op">=</span><span class="st">'1d'</span>, auto_adjust<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> df.empty:</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>                <span class="co"># no data for ticker in window</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>            df.index <span class="op">=</span> pd.to_datetime(df.index).normalize()</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># compute percent change on Close</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">'Adj Close'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>                price_col <span class="op">=</span> <span class="st">'Adj Close'</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>                price_col <span class="op">=</span> <span class="st">'Close'</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'pct_change'</span>] <span class="op">=</span> df[price_col].pct_change() <span class="op">*</span> <span class="fl">100.0</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># select only rows in [start_date, end_date]</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>            sel <span class="op">=</span> df.loc[(df.index <span class="op">&gt;=</span> start_date) <span class="op">&amp;</span> (df.index <span class="op">&lt;=</span> end_date)]</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fix: Properly select the pct_change column</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>            sel <span class="op">=</span> sel[[<span class="st">'pct_change'</span>]].dropna()</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> idx, r <span class="kw">in</span> sel.iterrows():</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>                rows.append({<span class="st">'DateOnly'</span>: idx, <span class="st">'Ticker'</span>: t, <span class="st">'Actual_Pct_Change'</span>: r[<span class="st">'pct_change'</span>]})</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"yfinance fetch failed for </span><span class="sc">{</span>t<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>    actuals_df <span class="op">=</span> pd.DataFrame(rows)</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> actuals_df.empty:</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        actuals_df[<span class="st">'DateOnly'</span>] <span class="op">=</span> pd.to_datetime(actuals_df[<span class="st">'DateOnly'</span>]).dt.normalize()</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> actuals_df</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to compare predictions with actuals</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_predictions(pred_mean, pred_index, actuals_df, ticker<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>    pred_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>        <span class="st">'DateOnly'</span>: pd.to_datetime(pred_index).normalize(),</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Predicted_Pct_Change'</span>: np.asarray(pred_mean).astype(<span class="bu">float</span>)</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ticker <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>        actuals_df <span class="op">=</span> actuals_df[actuals_df[<span class="st">'Ticker'</span>] <span class="op">==</span> ticker].copy()</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If actuals contain multiple tickers and ticker=None, will compare using all actual rows</span></span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    merged <span class="op">=</span> pd.merge(pred_df, actuals_df, on<span class="op">=</span><span class="st">'DateOnly'</span>, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> merged.empty:</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No overlapping observed days to compare (maybe market closed or today &lt; start)."</span>)</span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> merged, {}</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If actuals has multiple tickers for same DateOnly (if ticker=None), aggregated handling:</span></span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'Ticker'</span> <span class="kw">in</span> merged.columns <span class="kw">and</span> ticker <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>        <span class="co"># average actuals across tickers for that day</span></span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a>        aggregated <span class="op">=</span> merged.groupby(<span class="st">'DateOnly'</span>).agg({</span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a>            <span class="st">'Predicted_Pct_Change'</span>: <span class="st">'first'</span>,  </span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a>            <span class="st">'Actual_Pct_Change'</span>: <span class="st">'mean'</span></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a>        }).reset_index()</span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a>        mdf <span class="op">=</span> aggregated</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>        mdf <span class="op">=</span> merged[[<span class="st">'DateOnly'</span>, <span class="st">'Predicted_Pct_Change'</span>, <span class="st">'Actual_Pct_Change'</span>]].copy()</span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># metrics</span></span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>    mae <span class="op">=</span> mean_absolute_error(mdf[<span class="st">'Actual_Pct_Change'</span>], mdf[<span class="st">'Predicted_Pct_Change'</span>])</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>    rmse <span class="op">=</span> sqrt(mean_squared_error(mdf[<span class="st">'Actual_Pct_Change'</span>], mdf[<span class="st">'Predicted_Pct_Change'</span>]))</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    metrics <span class="op">=</span> {<span class="st">'count'</span>: <span class="bu">len</span>(mdf), <span class="st">'MAE'</span>: mae, <span class="st">'RMSE'</span>: rmse}</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mdf, metrics</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The evaluation metrics we use are the <strong>Mean Absolute Error (MAE)</strong> and <strong>Root Mean Squared Error (RMSE)</strong>, which measure how far off our predictions are from the actual stock price changes.</p>
<p>The MAE is the average of the absolute differences between predicted and actual values, while the RMSE is the square root of the average of squared differences. Usually, lower values of these metrics indicate better model performance.</p>
<p>The MAE is calculated as follows: <span class="math display">\[
\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|
\]</span> And the RMSE is calculated as follows: <span class="math display">\[
\text{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2}
\]</span></p>
<p>However, we must note that these metrics are not unitless, meaning they depend on the scale of the data. In our case, since we are predicting percentage changes in stock prices, the MAE and RMSE will be in percentage points.</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit the previous example for comparison</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>compare_start <span class="op">=</span> forecast_index[<span class="dv">0</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>compare_target_end <span class="op">=</span> forecast_index[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>compare_start, compare_end <span class="op">=</span> get_compare_window(compare_start, compare_target_end)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the actual comparison DataFrame</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>actuals_df <span class="op">=</span> fetch_actual_pct_changes(ai_tickers, compare_start, compare_end, buffer_days<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the metrics</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>pred_mean_values <span class="op">=</span> forecast_mean.values  <span class="co"># array-like</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>mdf, metrics <span class="op">=</span> compare_predictions(pred_mean_values, forecast_index, actuals_df)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Comparison metrics:"</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Count: </span><span class="sc">{</span>metrics[<span class="st">'count'</span>]<span class="sc">}</span><span class="ch">\n</span><span class="ss">MAE: </span><span class="sc">{</span>metrics[<span class="st">'MAE'</span>]<span class="sc">:.2f}</span><span class="ch">\n</span><span class="ss">RMSE: </span><span class="sc">{</span>metrics[<span class="st">'RMSE'</span>]<span class="sc">:.2f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> mdf.empty:</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(mdf.head())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, with the actual stock price data, let’s visualize it in the plot alongside our predictions to see if our confidence intervals capture the actual movements well.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the comparison and evaluate the confidence intervals</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>create_plot(final_df, forecast_mean, forecast_ci, forecast_index, actuals_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<ul>
<li><em>Do you think the model’s predictions are accurate enough for practical use?</em><br>
</li>
<li><em>What strategies could you use to:</em>
<ol type="1">
<li><em>Reduce the width of the confidence intervals?</em><br>
</li>
<li><em>Improve the accuracy of the predictions?</em><br>
</li>
<li><em>Increase the model’s robustness to outliers?</em></li>
</ol>
<em>Share your ideas with your classmates!</em></li>
</ul>
</blockquote>
</section>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>This notebook provides an overview of how large language models (LLMs) make predictions, typically with an example showing the distribution of a LLM’s prediction and an example of stock price forecasting based on historical data and news sentiment. It demonstrates how LLMs work and how they can be applied to real-world problems like stock price prediction. The use of LLM and sentiment analysis allows us to incorporate additional qualitative information into our predictions, potentially allowing for better inference and forecasting of economic variables like stock prices.</p>
<p>However, it is important to note that the model’s predictions are not perfect and should be used with caution. The notebook also highlights the importance of evaluating the model’s performance using metrics like MAE and RMSE, and encourages users to think critically about how to improve the model’s accuracy and robustness.</p>
</section>
<section id="key-takeaways" class="level3">
<h3 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h3>
<ul>
<li><strong>Large language models (LLMs)</strong> predict the next word in a sequence by learning the probability distribution of possible outcomes based on context.</li>
<li>LLMs can also be used to predict future values in a time series, such as stock prices, by incorporating additional features like public sentiment.</li>
<li><strong>The SARIMAX model</strong> is a powerful forecasting model that allows us to include external information, such as news sentiment, in our predictions.</li>
<li>We must evaluate the model’s performance using metrics like <strong>MAE</strong> and <strong>RMSE</strong> to ensure its predictions are reliable.</li>
</ul>
</section>
<section id="glossary" class="level3">
<h3 class="anchored" data-anchor-id="glossary">Glossary</h3>
<ul>
<li><strong>Large Language Model (LLM)</strong>: A type of AI model that predicts the next word in a sequence based on the context of previous words.</li>
<li><strong>Next Word Prediction</strong>: The task of predicting the next word in a sequence given the previous words.</li>
<li><strong>Sentiment Analysis</strong>: The process of determining the emotional tone behind a series of words, used to understand the sentiment expressed in text.</li>
<li><strong>SARIMAX Model</strong>: A statistical model used for forecasting time series data that can incorporate external variables.</li>
<li><strong>Mean Absolute Error (MAE)</strong>: A measure of prediction accuracy that calculates the average absolute difference between predicted and actual values.</li>
<li><strong>Root Mean Squared Error (RMSE)</strong>: A measure of prediction accuracy that calculates the square root of the average of squared differences between predicted and actual values.</li>
</ul>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<ul>
<li>Kirsch, N. (2024, April 29). 10 Best AI Stocks Of August 2024. Forbes Advisor. <a href="https://www.forbes.com/advisor/investing/best-ai-stocks/">https://www.forbes.com/advisor/investing/best-ai-stocks/</a></li>
<li>Chen, J. (2023, October 6). <em>Efficient Market Hypothesis (EMH): Forms and criticisms</em>. Investopedia. <a href="https://www.investopedia.com/terms/e/efficientmarkethypothesis.asp">https://www.investopedia.com/terms/e/efficientmarkethypothesis.asp</a></li>
<li>Yahoo Finance. (n.d.). Yahoo Finance — Stocks, financial news, quotes, and market data. Retrieved August 1, 2025, from <a href="https://ca.finance.yahoo.com/">https://ca.finance.yahoo.com/</a></li>
<li>Aroussi, R. (n.d.). yfinance [Python package]. GitHub. Retrieved August 1, 2025, from <a href="https://github.com/ranaroussi/yfinance">https://github.com/ranaroussi/yfinance</a></li>
<li>Li, T. (2025). finvizfinance (Version 1.1.1) [Python package]. PyPI. Retrieved August 1, 2025, from <a href="https://pypi.org/project/finvizfinance/">https://pypi.org/project/finvizfinance/</a></li>
<li>GeeksforGeeks. (2023, September 27). Complete guide to SARIMAX in Python. <a href="https://www.geeksforgeeks.org/python/complete-guide-to-sarimax-in-python/">https://www.geeksforgeeks.org/python/complete-guide-to-sarimax-in-python/</a></li>
<li>Sprenger, T. O., Tumasjan, A., Sandner, P. G., &amp; Welpe, I. M. (2014, February 5). <em>Twitter sentiment and stock market movements: The predictive power of social media</em>. VoxEU. <a href="https://cepr.org/voxeu/columns/twitter-sentiment-and-stock-market-movements-predictive-power-social-media">https://cepr.org/voxeu/columns/twitter-sentiment-and-stock-market-movements-predictive-power-social-media</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a>.  <a rel="license" href="https://comet.arts.ubc.ca/pages/copyright.html">See details.</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 The prAxIs Project and UBC are located on the traditional, ancestral and unceded territory of the xʷməθkʷəy̓əm (Musqueam) and Sḵwx̱wú7mesh (Squamish) peoples.
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>