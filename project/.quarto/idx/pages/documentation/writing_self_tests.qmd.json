{"title":"Writing Self-Tests for Notebook Development","markdown":{"yaml":{"title":"Writing Self-Tests for Notebook Development","author":"Jonathan Graves","date":"last-modified","number-sections":true,"version":1},"headingText":"General Framework","containsRefs":false,"markdown":"\n\nAn important part of notebook development is to design them so they give users _formative feedback_.  Formative feedback helps students check if they understand a concept or skill.\n\nWe prefer to use immediate formative feedback, by integrating tests into the notebooks.  These self-tests are run by the students and provide them with instant feedback about whether they have something correct or not.\n\nThis can be accomplished through the following process:\n\n* We create a *notebook_test* script which contains a series of functions which take in an object from the workbook and return feedback (e.g. correct/incorrect).\n* The object and correct answer are obfuscated using a [cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function) which checks the object against the correct answer without revealing the correct answer.\n  * This prevents students from hard-coding in their answers by simply peeking at the \"correct answer\".\n* The notebook instructs students to build or evaluate something, which is the object of the test.\n* The notebook reads in the script, passing in the testing functions for use.  These tests are then evaluate when certain cells are run, performing the test and giving feedback.\n\nIt is also *very* important to follow best practices when developing these notebooks and tests, since even small mistakes can create a great deal of confusion for users.\n\n\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, include a source function call to the test scripts file:\n\n```r\nsource(tests.r)\n```\n\nThis file should include the tests, as outlined below in @sec-r-tests.  In this example, they are of the form `test()`.\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, import the `Tests` class from the test scripts file:\n\n```python\nfrom .tests.py import *\n```\n\nThis file should include the tests, as outlined below in @sec-py-tests.  In this example, they are of the form `test()`, and are called like `Tests.test()`.\n\n:::\n\n### Use in Jupyter Notebooks (`.ipynb`)\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nIn the notebook, ask the students to fill in the object requested, then call the test function.  Add a comment to explain what needs to be changed, if it's not clear.\n\n```r\nanswer_1 <- #fill in the correct value here\n\ntest_1()\n```\n\n* Try to make the test function is a void call; avoid passing parameters.\n* Clearly indicate what to change using `#comments`.\n* Be as specific as possible when giving directions.\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\nIn the notebook, ask the students to fill in the object requested, then call the test function.  Add a comment to explain what needs to be changed, if it's not clear.\n\n```python\nanswer_1 = #fill in the correct value here\n\nTests.test()\n```\n* Try to make the test function is a void call; avoid passing parameters.\n* Clearly indicate what to change using `#comments`.\n* Be as specific as possible when giving directions.\n:::\n\n## Answers in `.qmd` notebooks\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, include a source link to the test scripts file:\n\n```r\nsource(tests.r)\n```\n\n\nThis file should include the tests, as outlined below in @sec-r-tests.  In this example, they are of the form `test()`.\n\nIn `.qmd` notebooks, when you write a test include _two versions_: one with the answers, and one without.  Include meta class tags to help tell them apart, and avoid evaluation.  The cell should look like:\n\n```r\n#| eval: false\n#| classes: \"question\"\n\nanswer_1 <- #fill in the correct value here\n\ntest_1()\n```\n\nfor the question, and like:\n\n```r\n#| eval: false\n#| classes: \"answer\"\n\nanswer_1 <- the_right_answer(stuff)\n\ntest_1()\n```\n\nfor the answer.  This will help debug questions easily.\n\n:::{.callout-tip}\nIt's usually easiest to write the answer first, then debug and test.\n:::\n\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\n\nEarly in the notebook, usually in the first executed cell, import the `Tests` class from the test scripts file:\n\n```python\nfrom .tests.py import Tests\n```\n\nThis file should include the tests, as outlined below in @sec-py-tests.  In this example, they are of the form `test()`, and are called like `Tests.test()`.\n\nIn `.qmd` notebooks, when you write a test, include _two versions_: one with the answers, and one without.  Include meta class tags to help tell them apart, and avoid evaluation.  The cell should look like:\n\n```r\n#| eval: false\n#| classes: \"question\"\n\nanswer_1 = #fill in the correct value here\n\nTests.test_1()\n```\n\nfor the question, and like:\n\n```r\n#| eval: false\n#| classes: \"answer\"\n\nanswer_1 = the_right_answer(stuff)\n\nTests.test_1()\n```\n\nfor the answer.  This will help debug questions easily.\n\n:::{.callout-tip}\nIt's usually easiest to write the answer first, then debug and test.\n:::\n\n::: \n\n\n## Writing R Self-Tests {#sec-r-tests}\n\nSelf-test scripts are `R` files (`.r`) which supply the testing functions.  They use two libraries:\n\n* `library(testthat)`: a test assertion library, which provides functions to check if something is correct and give feedback.\n* `library(digest)`: a hash library, which computes and check hash functions.\n\nHere is an example of the first function of a file and the library headers:\n\n```r\nlibrary(testthat)\nlibrary(digest)\n\ntest_1 <- function() {\n  test_that(\"Solution is incorrect\", {\n    expect_equal(digest(answer1), \"dbc09cba9fe2583fb01d63c70e1555a8\")\n  })\n  print(\"Success!\")\n}\n```\n\nThis creates a function (`test1()`) that when called in the Jupyter notebook:\n\n* Finds the object `answer1`.\n* Computes the hash of it (`digest(answer)`) and compares it to the string `dbc09cba9fe2583fb01d63c70e1555a8` (the correct answer's hash).\n* If they match, it prints \"Success!\" otherwise it throws an error.\n\nIn order to develop the test, you can use this template:\n\n1. Create a new cell to contain the test.  If this a `.qmd` test, make it the answer version of the test.\n2. Create a new function in the script file with a unique name (`test_n()`) and the answer (`answer_n`) to test in the testing script.\n3. Compute `digest(answer_n)` to get the correct has value.\n4. Add it to the `expect_equal` element in the script.\n5. If a `.qmd` copy the answer, and change it to a question.  Then, replace the correct answer with a comment.\n\nNote that you may not want to test the entire object, but rather some particular part of it, such as `answer_n$coefs`; see @sec-important for details.\n\n### Richer Feedback {#sec-richer}\n\nThe previous method only tests if an answer _exactly_ matches the correct answer. If there are common errors you may want to give a hint about what is wrong. For example, in a multiple-choice question, answers `A` and `B` reflect common misconceptions. \n\nYou can use tests to give this kind of feedback with a more complex test function. Use the ``case_when`` function to give varied responses depending on the answer given by the student. For example:  \n\n\n```r\ntest_1 <- function(answer_1) {\n    ans <- digest(answer_1)\n    case_when(ans == \"dbc09cba9fe2583fb01d63c70e1555a8\" ~ test_that(TRUE),\n             ans == \"dd531643bffc240879f11278d7a360c1\" ~ \n              \"This is a common misconception, remember that...\",\n              TRUE ~ test_that(FALSE))\n}\n``` \nYou can adapt this framework for more complex tests, as necessary.\n\n\n:::{.callout-important}\n## A Note on Feedback\n\nIt is important to provide feedback that will guide the student towards the right answer and a greater understanding of the topic at hand. Try not to give feedback along the lines of \"That is correct, congratulations!\" or \"I'm sorry, that is incorrect!.\" Feedback should point out the error that students are making and guide them to the correct answer. \n:::\n\n### Important Notes {#sec-important}\n\nHere are some common pitfalls and notes about creating tests.  The main idea is that hash functions are exact: the objects must be _exactly_ the same.  This means you should:\n\n * *Always* round numbers to 3 or 4 decimal places using the `round()` function.  Do this in the testing function, rather than making students do it.\n* *Never* test objects that include arbitrary elements, such as names or sequences.\n* *Only* test the simplest object necessary, not the easiest one to test.\n\nFor example, the following objects will return different hashes:\n\n```r\nd1 <- data.frame(age = \"12\")\nd2 <- data.frame(Age = \"12\")\n\ndigest(d1) # == d2da0d698613f4cafa7d6fe5af762294\ndigest(d2) # == cfe4cbf9291d5705b2c61422098db883\n```\n\nHere are some examples of arbitrary elements that you can miss:\n\n* Object or variable names (`Age` != `age`)\n* Regression models (`y ~ x1 + x2` != `y ~ x2 + x1`)\n* Floating point numbers (1.222222222222 != 1.222222222222)\n* Methods that us randomization (e.g., [Monte Carlo methods](https://en.wikipedia.org/wiki/Monte_Carlo_method))\n\nBottom line: **only test mathematical or textual objects, not programming objects** unless you are very, very explicit about them.\n\n## Writing Python Self-Tests {#sec-py-tests}\n\n\nPython self-test scripts are Python files (`.py`) which supply the testing function in a test class.  They use two libraries:\n\n* `unittest`: a test assertion library, which provides functions to check if something is correct and give feedback.\n* `hashlib`: a hash library, which computes and check hash functions, and report the `hexdigest` of one.\n\nHere is an example of the first function of a file and the library headers:\n\n```python\n\nfrom hashlib import blake2b\nimport unittest import TestCase as t\n\n# Don't change this one\ndef hash(data):\n    h = blake2b(digest_size=20)\n    h.update(data)\n    return h.hexdigest()\n\n\nclass Test():\n\n  def test1():\n    t.assertEqual(hash(answer1), \"dbc09cba9fe2583fb01d63c70e1555a8\")\n\n```\n\nSee @sec-richer and @sec-important for guidelines above writing richer tests, and some common mistakes.  The issues and advice applies to Python as well.\n\n\n## Other Uses for Tests\n\nYou can also write \"hidden\" tests for developers; this is recommended when you have a complex example with interdependent parts.  Try to make these as hidden as possible from the main notebook; hide them in a supplemental file which is included at runtime.\n","srcMarkdownNoYaml":"\n\nAn important part of notebook development is to design them so they give users _formative feedback_.  Formative feedback helps students check if they understand a concept or skill.\n\nWe prefer to use immediate formative feedback, by integrating tests into the notebooks.  These self-tests are run by the students and provide them with instant feedback about whether they have something correct or not.\n\nThis can be accomplished through the following process:\n\n* We create a *notebook_test* script which contains a series of functions which take in an object from the workbook and return feedback (e.g. correct/incorrect).\n* The object and correct answer are obfuscated using a [cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function) which checks the object against the correct answer without revealing the correct answer.\n  * This prevents students from hard-coding in their answers by simply peeking at the \"correct answer\".\n* The notebook instructs students to build or evaluate something, which is the object of the test.\n* The notebook reads in the script, passing in the testing functions for use.  These tests are then evaluate when certain cells are run, performing the test and giving feedback.\n\nIt is also *very* important to follow best practices when developing these notebooks and tests, since even small mistakes can create a great deal of confusion for users.\n\n\n## General Framework\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, include a source function call to the test scripts file:\n\n```r\nsource(tests.r)\n```\n\nThis file should include the tests, as outlined below in @sec-r-tests.  In this example, they are of the form `test()`.\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, import the `Tests` class from the test scripts file:\n\n```python\nfrom .tests.py import *\n```\n\nThis file should include the tests, as outlined below in @sec-py-tests.  In this example, they are of the form `test()`, and are called like `Tests.test()`.\n\n:::\n\n### Use in Jupyter Notebooks (`.ipynb`)\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nIn the notebook, ask the students to fill in the object requested, then call the test function.  Add a comment to explain what needs to be changed, if it's not clear.\n\n```r\nanswer_1 <- #fill in the correct value here\n\ntest_1()\n```\n\n* Try to make the test function is a void call; avoid passing parameters.\n* Clearly indicate what to change using `#comments`.\n* Be as specific as possible when giving directions.\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\nIn the notebook, ask the students to fill in the object requested, then call the test function.  Add a comment to explain what needs to be changed, if it's not clear.\n\n```python\nanswer_1 = #fill in the correct value here\n\nTests.test()\n```\n* Try to make the test function is a void call; avoid passing parameters.\n* Clearly indicate what to change using `#comments`.\n* Be as specific as possible when giving directions.\n:::\n\n## Answers in `.qmd` notebooks\n\n::: {.panel-tabset}\n\n## R Kernels\n\n### R Kernels {.unnumbered}\n\nEarly in the notebook, usually in the first executed cell, include a source link to the test scripts file:\n\n```r\nsource(tests.r)\n```\n\n\nThis file should include the tests, as outlined below in @sec-r-tests.  In this example, they are of the form `test()`.\n\nIn `.qmd` notebooks, when you write a test include _two versions_: one with the answers, and one without.  Include meta class tags to help tell them apart, and avoid evaluation.  The cell should look like:\n\n```r\n#| eval: false\n#| classes: \"question\"\n\nanswer_1 <- #fill in the correct value here\n\ntest_1()\n```\n\nfor the question, and like:\n\n```r\n#| eval: false\n#| classes: \"answer\"\n\nanswer_1 <- the_right_answer(stuff)\n\ntest_1()\n```\n\nfor the answer.  This will help debug questions easily.\n\n:::{.callout-tip}\nIt's usually easiest to write the answer first, then debug and test.\n:::\n\n\n## Python Kernels\n\n### Python Kernels {.unnumbered}\n\n\nEarly in the notebook, usually in the first executed cell, import the `Tests` class from the test scripts file:\n\n```python\nfrom .tests.py import Tests\n```\n\nThis file should include the tests, as outlined below in @sec-py-tests.  In this example, they are of the form `test()`, and are called like `Tests.test()`.\n\nIn `.qmd` notebooks, when you write a test, include _two versions_: one with the answers, and one without.  Include meta class tags to help tell them apart, and avoid evaluation.  The cell should look like:\n\n```r\n#| eval: false\n#| classes: \"question\"\n\nanswer_1 = #fill in the correct value here\n\nTests.test_1()\n```\n\nfor the question, and like:\n\n```r\n#| eval: false\n#| classes: \"answer\"\n\nanswer_1 = the_right_answer(stuff)\n\nTests.test_1()\n```\n\nfor the answer.  This will help debug questions easily.\n\n:::{.callout-tip}\nIt's usually easiest to write the answer first, then debug and test.\n:::\n\n::: \n\n\n## Writing R Self-Tests {#sec-r-tests}\n\nSelf-test scripts are `R` files (`.r`) which supply the testing functions.  They use two libraries:\n\n* `library(testthat)`: a test assertion library, which provides functions to check if something is correct and give feedback.\n* `library(digest)`: a hash library, which computes and check hash functions.\n\nHere is an example of the first function of a file and the library headers:\n\n```r\nlibrary(testthat)\nlibrary(digest)\n\ntest_1 <- function() {\n  test_that(\"Solution is incorrect\", {\n    expect_equal(digest(answer1), \"dbc09cba9fe2583fb01d63c70e1555a8\")\n  })\n  print(\"Success!\")\n}\n```\n\nThis creates a function (`test1()`) that when called in the Jupyter notebook:\n\n* Finds the object `answer1`.\n* Computes the hash of it (`digest(answer)`) and compares it to the string `dbc09cba9fe2583fb01d63c70e1555a8` (the correct answer's hash).\n* If they match, it prints \"Success!\" otherwise it throws an error.\n\nIn order to develop the test, you can use this template:\n\n1. Create a new cell to contain the test.  If this a `.qmd` test, make it the answer version of the test.\n2. Create a new function in the script file with a unique name (`test_n()`) and the answer (`answer_n`) to test in the testing script.\n3. Compute `digest(answer_n)` to get the correct has value.\n4. Add it to the `expect_equal` element in the script.\n5. If a `.qmd` copy the answer, and change it to a question.  Then, replace the correct answer with a comment.\n\nNote that you may not want to test the entire object, but rather some particular part of it, such as `answer_n$coefs`; see @sec-important for details.\n\n### Richer Feedback {#sec-richer}\n\nThe previous method only tests if an answer _exactly_ matches the correct answer. If there are common errors you may want to give a hint about what is wrong. For example, in a multiple-choice question, answers `A` and `B` reflect common misconceptions. \n\nYou can use tests to give this kind of feedback with a more complex test function. Use the ``case_when`` function to give varied responses depending on the answer given by the student. For example:  \n\n\n```r\ntest_1 <- function(answer_1) {\n    ans <- digest(answer_1)\n    case_when(ans == \"dbc09cba9fe2583fb01d63c70e1555a8\" ~ test_that(TRUE),\n             ans == \"dd531643bffc240879f11278d7a360c1\" ~ \n              \"This is a common misconception, remember that...\",\n              TRUE ~ test_that(FALSE))\n}\n``` \nYou can adapt this framework for more complex tests, as necessary.\n\n\n:::{.callout-important}\n## A Note on Feedback\n\nIt is important to provide feedback that will guide the student towards the right answer and a greater understanding of the topic at hand. Try not to give feedback along the lines of \"That is correct, congratulations!\" or \"I'm sorry, that is incorrect!.\" Feedback should point out the error that students are making and guide them to the correct answer. \n:::\n\n### Important Notes {#sec-important}\n\nHere are some common pitfalls and notes about creating tests.  The main idea is that hash functions are exact: the objects must be _exactly_ the same.  This means you should:\n\n * *Always* round numbers to 3 or 4 decimal places using the `round()` function.  Do this in the testing function, rather than making students do it.\n* *Never* test objects that include arbitrary elements, such as names or sequences.\n* *Only* test the simplest object necessary, not the easiest one to test.\n\nFor example, the following objects will return different hashes:\n\n```r\nd1 <- data.frame(age = \"12\")\nd2 <- data.frame(Age = \"12\")\n\ndigest(d1) # == d2da0d698613f4cafa7d6fe5af762294\ndigest(d2) # == cfe4cbf9291d5705b2c61422098db883\n```\n\nHere are some examples of arbitrary elements that you can miss:\n\n* Object or variable names (`Age` != `age`)\n* Regression models (`y ~ x1 + x2` != `y ~ x2 + x1`)\n* Floating point numbers (1.222222222222 != 1.222222222222)\n* Methods that us randomization (e.g., [Monte Carlo methods](https://en.wikipedia.org/wiki/Monte_Carlo_method))\n\nBottom line: **only test mathematical or textual objects, not programming objects** unless you are very, very explicit about them.\n\n## Writing Python Self-Tests {#sec-py-tests}\n\n\nPython self-test scripts are Python files (`.py`) which supply the testing function in a test class.  They use two libraries:\n\n* `unittest`: a test assertion library, which provides functions to check if something is correct and give feedback.\n* `hashlib`: a hash library, which computes and check hash functions, and report the `hexdigest` of one.\n\nHere is an example of the first function of a file and the library headers:\n\n```python\n\nfrom hashlib import blake2b\nimport unittest import TestCase as t\n\n# Don't change this one\ndef hash(data):\n    h = blake2b(digest_size=20)\n    h.update(data)\n    return h.hexdigest()\n\n\nclass Test():\n\n  def test1():\n    t.assertEqual(hash(answer1), \"dbc09cba9fe2583fb01d63c70e1555a8\")\n\n```\n\nSee @sec-richer and @sec-important for guidelines above writing richer tests, and some common mistakes.  The issues and advice applies to Python as well.\n\n\n## Other Uses for Tests\n\nYou can also write \"hidden\" tests for developers; this is recommended when you have a complex example with interdependent parts.  Try to make these as hidden as possible from the main notebook; hide them in a supplemental file which is included at runtime.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":false,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["answers"],"css":["../../styles.css"],"toc":true,"email-obfuscation":"javascript","include-in-header":["../../metadata.html"],"number-sections":true,"output-file":"writing_self_tests.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en-GB","fig-responsive":true,"quarto-version":"1.5.57","theme":{"light":["sandstone","../../comet_theme.scss"]},"anchor-sections":true,"page-layout":"full","title":"Writing Self-Tests for Notebook Development","author":"Jonathan Graves","date":"last-modified","version":1},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}